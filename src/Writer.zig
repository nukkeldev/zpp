//! Given the results of `read.zig`'s parsing, outputs an `extern "C"` compatible .cpp file for FFI
//! usage as well as a Zig binding.

// -- Imports -- //

const std = @import("std");

const Reader = @import("Reader.zig");
const Writer = @This();

const AST = Reader.AST;
const CppType = Reader.CppType;

const Allocator = std.mem.Allocator;

// -- State -- //

annotate: bool = false,

allocator: Allocator,
source_filename: []const u8,
ast: AST,

// -- C++ -- //

const CPP_TEMPLATE_FILE =
        \\// This file was auto-generated by github:nukkeldev/zpp.
        \\// It is an extern "C" compatible wrapper for the include below.
        \\
        \\#include "{[filename]s}"
        \\
        \\extern "C" {{ // extern "C"
        \\    {[functions]f}
        \\}} // extern "C"
        \\
;

const CPP_TEMPLATE_FUNCTION =
    \\{[indent]s}{[return_type]f} {[namespace_prefix]s}{[function_name]s}() {{
    \\{[indent]s}{[indent]s}return 
    \\{[indent]s}}}
    \\
;

/// Writes the AST as a extern "C" C++ file.
pub fn cppFormat(writer: Writer, io_writer: *std.io.Writer) !void {
    _ = writer;
    _ = io_writer;
}

pub fn formatCppTypeForExternC(cpp_type: CppType, ast: *const AST, writer: *std.io.Writer) !void {
    if (cpp_type.is_const) try writer.print("const ", .{});

    switch (cpp_type.inner) {
        // TODO: This might be a good use-case for retaining the CXType.
        .unexposed => try writer.print("void*", .{}),
        .void => try writer.print("void", .{}),
        .bool => try writer.print("bool", .{}),
        .i8 => try writer.print("char", .{}),
        .u8 => try writer.print("unsigned char", .{}),
        .i16 => try writer.print("short", .{}),
        .u16 => try writer.print("unsigned short", .{}),
        .i32 => try writer.print("int", .{}),
        .u32 => try writer.print("unsigned int", .{}),
        .i64 => try writer.print("long long", .{}),
        .u64 => try writer.print("unsigned long long", .{}),
        .f32 => try writer.print("float", .{}),
        .f64 => try writer.print("double", .{}),
        .pointer => |pointee| {
            try formatCppTypeForExternC(pointee.*, ast, writer);
            try writer.print("*", .{});
        },
        .reference => |ref| {
            try formatCppTypeForExternC(ref.*, ast, writer);
            try writer.print("*", .{});
        },
        .array, .slice => @panic("Cannot format an array-type without knowing the parameter name."),
        .record => |name| try writer.print("{s}", .{name}),
        .@"enum" => |name| try writer.print("{s}", .{name}),
        .closure => |_| try writer.print("void*", .{}),
    }
}

pub fn formatCppParamForExternC(cpp_type: CppType, name: []const u8, ast: *const AST, writer: *std.io.Writer) !void {
    switch (cpp_type.inner) {
        .array => |arr| {
            try formatCppTypeForExternC(arr.@"1".*, ast, writer);
            try writer.print(" {s}[{}]", .{ name, arr.@"0" });
        },
        .slice => |elm| {
            try formatCppTypeForExternC(elm.*, ast, writer);
            try writer.print(" {s}[]", .{name});
        },
        else => {
            try formatCppTypeForExternC(cpp_type, ast, writer);
            try writer.print(" {s}", .{name});
        },
    }
}

// -- Zig -- //

pub fn zigFormat(writer: Writer, io_writer: *std.io.Writer) !void {
    _ = writer;
    _ = io_writer;
}
