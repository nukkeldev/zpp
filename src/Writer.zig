//! Given the results of `read.zig`'s parsing, outputs an `extern "C"` compatible .cpp file for FFI
//! usage as well as a Zig binding.

// -- Imports -- //

const std = @import("std");

const Reader = @import("Reader.zig");
const Writer = @This();

const AST = Reader.AST;
const CppType = Reader.CppType;

const Allocator = std.mem.Allocator;

// -- Constants -- //

const INDENT = "    ";

const VOID_PTR_TYPE: CppType = .{
    .is_const = false,
    .align_ = @alignOf(*void),
    .size = @sizeOf(*void),
    .inner = .{
        .pointer = &.{
            .align_ = -1,
            .size = -1,
            .is_const = false,
            .inner = .void,
        },
    },
};

const CONST_VOID_PTR_TYPE: CppType = .{
    .is_const = false,
    .align_ = @alignOf(*void),
    .size = @sizeOf(*void),
    .inner = .{
        .pointer = &.{
            .align_ = -1,
            .size = -1,
            .is_const = true,
            .inner = .void,
        },
    },
};

const log = std.log.scoped(.writer);

// -- State -- //

/// The language we are writing.
language: Language,
/// Whether to annotate the output with comments detailing AST attributes.
annotate: bool = false,

/// An allocator; nothing is freed.
allocator: Allocator,
/// The source filename that the AST came from.
/// Used, for instance, for including symbols in C++.
source_filename: []const u8,
/// The abstract syntax tree.
ast: AST,

/// An index to correlate log statements to annotations.
debug_idx: usize = 0,
function_overload_counts: std.StringHashMap(usize),

/// The language target for the `Writer`.
const Language = enum {
    /// Writes a C++ file that provides extern "C" wrappers for the AST's functions.
    Cpp,
    /// Writes a Zig file that uses the C++ extern "C" wrappers and re-implements the structs and enums.
    Zig,
};

// -- Formatting -- //

pub fn format(writer: *Writer, io_writer: *std.io.Writer) !void {
    switch (writer.language) {
        .Cpp => try formatCpp(writer, io_writer),
        .Zig => try formatZig(writer, io_writer),
    }
}

// -- C++ -- //

const CPP_TEMPLATE_FILE =
    \\// This file was auto-generated by github:nukkeldev/zpp.
    \\// It is an extern "C" compatible wrapper for the include below.
    \\
    \\#include "{[filename]s}"
    \\
    \\#include <cstdarg>
    \\
    \\#pragma clang diagnostic push
    \\#pragma clang diagnostic ignored "-Wformat-security"
    \\
    \\extern "C" {{ // extern "C"
    \\{[functions]f}
    \\}} // extern "C"
    \\
    \\#pragma clang diagnostic pop
    \\
;

const CPP_TEMPLATE_FUNCTION =
    \\{[indent]s}{[return_type]f} {[name_namespace_prefix]s}{[name]s}{[overload_idx]s}({[parameters]f}) {{
    \\{[indent]s}{[indent]s}{[might_return]s}{[return_prefix]s}{[namespace_prefix]s}{[name]s}({[arguments]f}){[return_suffix]s};
    \\{[indent]s}}}
    \\
;

const CPP_TEMPLATE_VARIADIC_FUNCTION =
    \\{[indent]s}{[return_type]f} {[name_namespace_prefix]s}{[name]s}{[overload_idx]s}({[parameters]f}) {{
    \\{[indent]s}{[indent]s}va_list ZPP_args;
    \\{[indent]s}{[indent]s}va_start(ZPP_args, {[after_param]s});
    \\{[indent]s}{[indent]s}{[might_return]s}{[return_prefix]s}{[namespace_prefix]s}{[name]s}({[arguments]f}){[return_suffix]s};
    \\{[indent]s}{[indent]s}va_end(ZPP_args);
    \\{[indent]s}}}
    \\
;

pub fn formatCpp(writer: *Writer, io_writer: *std.io.Writer) !void {
    log.debug("Writing AST as C++ file.", .{});
    try io_writer.print(CPP_TEMPLATE_FILE, .{
        .filename = writer.source_filename,
        .functions = FormatCppFunctions{ .writer = writer },
    });
}

const FormatCppFunctions = struct {
    writer: *Writer,

    pub fn format(fmt: FormatCppFunctions, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        log.debug("Writing {} functions.", .{fmt.writer.ast.functions.items.len});
        for (fmt.writer.ast.functions.items) |*func| {
            log.debug("Writing function '{s}' in resolved namespace '{s}'.", .{ func.name, func.resolved_namespace_prefix });
            const overload_idx_ptr = (fmt.writer.function_overload_counts.getOrPutValue(func.name, 0) catch |e| fatal(e)).value_ptr;
            if (overload_idx_ptr.* > 0) log.debug("This is overload #{}.", .{overload_idx_ptr.*});

            const overload_idx = if (overload_idx_ptr.* > 0)
                std.fmt.allocPrint(fmt.writer.allocator, "{}", .{overload_idx_ptr.*}) catch |e| fatal(e)
            else
                "";

            const how_should_i_handle_the_return_type = howShouldIHandleTheReturnType(&func.return_type);
            log.debug("Return type of '{s}' means we will use {}.", .{ @tagName(func.return_type.inner), how_should_i_handle_the_return_type });

            const return_type = switch (how_should_i_handle_the_return_type) {
                .Primitive => FormatCppType{ .type = &func.return_type, .writer = fmt.writer },
                .Pointer => outer: {
                    const const_pointee = func.return_type.inner.pointer.is_const;
                    if (const_pointee) {
                        log.debug("Return type pointee is const.", .{});
                        break :outer FormatCppType{ .type = &CONST_VOID_PTR_TYPE, .writer = fmt.writer };
                    } else {
                        break :outer FormatCppType{ .type = &VOID_PTR_TYPE, .writer = fmt.writer };
                    }
                },
                else => FormatCppType{ .type = &CppType{ .is_const = false, .inner = .void, .align_ = -1, .size = -1 }, .writer = fmt.writer },
            };

            const namespace_prefix = Reader.getNamespacePrefixWithSeperator(fmt.writer.allocator, func.namespace, &fmt.writer.ast, "::") catch |e| fatal(e);

            const might_return = if (how_should_i_handle_the_return_type == .Primitive or how_should_i_handle_the_return_type == .Pointer) "return " else "";
            const return_prefix = if (func.return_type.inner == .reference) "&" else "";

            if (func.variadic) {
                try io_writer.print(CPP_TEMPLATE_VARIADIC_FUNCTION, .{
                    .indent = INDENT,
                    .return_type = return_type,
                    .after_param = func.parameters.getLast().name,
                    .name_namespace_prefix = func.resolved_namespace_prefix,
                    .name = func.name,
                    .overload_idx = overload_idx,
                    .parameters = FormatCppParameters{ .func = func, .writer = fmt.writer },
                    .might_return = might_return,
                    .return_prefix = return_prefix, // TODO
                    .namespace_prefix = namespace_prefix,
                    .arguments = FormatCppArguments{ .func = func, .writer = fmt.writer },
                    .return_suffix = "", // TODO
                });
            } else {
                try io_writer.print(CPP_TEMPLATE_FUNCTION, .{
                    .indent = INDENT,
                    .return_type = return_type,
                    .name_namespace_prefix = func.resolved_namespace_prefix,
                    .name = func.name,
                    .overload_idx = overload_idx,
                    .parameters = FormatCppParameters{ .func = func, .writer = fmt.writer },
                    .might_return = might_return,
                    .return_prefix = return_prefix, // TODO
                    .namespace_prefix = namespace_prefix,
                    .arguments = FormatCppArguments{ .func = func, .writer = fmt.writer },
                    .return_suffix = "", // TODO
                });
            }
            overload_idx_ptr.* += 1;
        }
    }
};

const FormatCppParameters = struct {
    func: *const Reader.CppFunctionDecl,
    writer: *Writer,

    pub fn format(fmt: FormatCppParameters, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.func.parameters.items, 0..) |param, i| {
            switch (param.type.inner) {
                .array => |arr| try io_writer.print("{f} {s}[{}]", .{ FormatCppType{ .type = arr.@"1", .writer = fmt.writer }, param.name, arr.@"0" }),
                .slice => |elm| try io_writer.print("{f} {s}[]", .{ FormatCppType{ .type = elm, .writer = fmt.writer }, param.name }),
                .pointer => |pointee| switch (pointee.inner) {
                    .closure => |idx| {
                        const decl = fmt.writer.ast.closures.items[idx];
                        try io_writer.print("{[return_type]f} (*{[name]s})({[parameters]f})", .{
                            .return_type = FormatCppType{ .type = &decl.return_type, .writer = fmt.writer },
                            .name = param.name,
                            .parameters = FormatCppClosureParameters{ .decl = &decl, .writer = fmt.writer },
                        });
                    },
                    else => try io_writer.print("{f} {s}", .{ FormatCppType{ .type = &param.type, .writer = fmt.writer }, param.name }),
                },
                else => try io_writer.print("{f} {s}", .{ FormatCppType{ .type = &param.type, .writer = fmt.writer }, param.name }),
            }
            if (fmt.func.variadic or i < fmt.func.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
        if (fmt.func.variadic) try io_writer.print("...", .{});
    }
};

const FormatCppArguments = struct {
    func: *const Reader.CppFunctionDecl,
    writer: *Writer,

    pub fn format(fmt: FormatCppArguments, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.func.parameters.items, 0..) |param, i| {
            switch (param.type.inner) {
                .reference => try io_writer.print("*{s}", .{param.name}),
                .pointer => try io_writer.print("reinterpret_cast<{s}>({s})", .{ param.type.raw_type_spelling, param.name }),
                else => try io_writer.print("{s}", .{param.name}),
            }
            if (i < fmt.func.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
    }
};

const FormatCppClosureParameters = struct {
    decl: *const Reader.CppFunctionDecl,
    writer: *Writer,

    pub fn format(fmt: FormatCppClosureParameters, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.decl.parameters.items, 0..) |param, i| {
            try (FormatCppType{ .type = &param.type, .writer = fmt.writer }).format(io_writer);
            if (i < fmt.decl.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
    }
};

const FormatCppType = struct {
    type: *const CppType,
    writer: *Writer,
    ignore_const: bool = false,

    pub fn format(fmt: FormatCppType, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        log.debug("[{}] Formatting type '{s}'.", .{ fmt.writer.debug_idx, @tagName(fmt.type.inner) });
        if (fmt.type.is_const) {
            log.debug("Type is const.", .{});
            if (fmt.ignore_const) log.debug("But we are ignoring that...", .{});
        }

        if (fmt.writer.annotate) {
            try io_writer.print("/* {}:{s}:{}:'{s}' */ ", .{
                fmt.writer.debug_idx,
                @tagName(fmt.type.inner),
                fmt.type.is_const,
                fmt.type.raw_type_spelling,
            });
        }
        fmt.writer.debug_idx += 1;
        if (!fmt.ignore_const and fmt.type.is_const) try io_writer.print("const ", .{});

        switch (fmt.type.inner) {
            // TODO: This might be a good use-case for retaining the CXType.
            .unexposed => try io_writer.print("void*", .{}),
            .void => try io_writer.print("void", .{}),
            .bool => try io_writer.print("bool", .{}),
            .i8 => try io_writer.print("char", .{}),
            .u8 => try io_writer.print("unsigned char", .{}),
            .i16 => try io_writer.print("short", .{}),
            .u16 => try io_writer.print("unsigned short", .{}),
            .i32 => try io_writer.print("int", .{}),
            .u32 => try io_writer.print("unsigned int", .{}),
            .i64 => try io_writer.print("long long", .{}),
            .u64 => try io_writer.print("unsigned long long", .{}),
            .f32 => try io_writer.print("float", .{}),
            .f64 => try io_writer.print("double", .{}),
            .pointer => |pointee| try io_writer.print("{f}*", .{FormatCppType{ .type = pointee, .writer = fmt.writer, .ignore_const = fmt.type.is_const or fmt.ignore_const }}),
            .reference => |ref| try io_writer.print("{f}*", .{FormatCppType{ .type = ref, .writer = fmt.writer, .ignore_const = fmt.type.is_const or fmt.ignore_const }}),
            .record => |st| try io_writer.print("{s}", .{st.@"1"}),
            .@"enum" => |name| try io_writer.print("{s}", .{name}),
            .closure => |_| try io_writer.print("void*", .{}),
            else => @panic("TODO: I don't think you can do this as a return type?"),
        }
    }
};

const ReturnTypeBehav = enum {
    Void,
    Primitive,
    Pointer,
    Record,
};

fn howShouldIHandleTheReturnType(cpp_type: *const CppType) ReturnTypeBehav {
    return switch (cpp_type.inner) {
        .void => .Void,
        .pointer => .Pointer,
        .record => .Record,
        else => .Primitive,
    };
}

// -- Zig -- //

pub fn formatZig(writer: *Writer, io_writer: *std.io.Writer) !void {
    log.debug("Writing AST as Zig file.", .{});

    try io_writer.print(
        \\// This file was auto-generated by github:nukkeldev/zpp.
        \\// It works with the accompanied auto-generated C++ file.
        \\
        \\// -- Structs -- //
        \\
        \\
    , .{});

    var struct_iter = writer.ast.structs.valueIterator();
    while (struct_iter.next()) |@"struct"| {
        try FormatZigStruct.format(.{ .@"struct" = @"struct", .writer = writer }, io_writer);
        try io_writer.print("\n", .{});
    }

    try io_writer.print("// -- Enums -- //\n\n", .{});

    var enum_iter = writer.ast.enums.valueIterator();
    while (enum_iter.next()) |@"enum"| {
        try FormatZigEnum.format(.{ .@"enum" = @"enum", .writer = writer }, io_writer);
        try io_writer.print("\n", .{});
    }

    try io_writer.print("// -- Functions -- //\n\n", .{});

    for (writer.ast.functions.items) |func| {
        const overload_idx_ptr = (writer.function_overload_counts.getOrPutValue(func.name, 0) catch |e| fatal(e)).value_ptr;
        defer overload_idx_ptr.* += 1;

        const overload_idx = if (overload_idx_ptr.* > 0)
            std.fmt.allocPrint(writer.allocator, "{}", .{overload_idx_ptr.*}) catch |e| fatal(e)
        else
            "";

        try io_writer.print("{[indent]s}pub extern fn {[namespace]s}{[name]s}{[overload_idx]s}(", .{
            .indent = "",
            .namespace = func.resolved_namespace_prefix,
            .name = func.name,
            .overload_idx = overload_idx,
        });

        for (func.parameters.items, 0..) |param, i| {
            try io_writer.print("{[name]s}: {[type]f}", .{ .name = param.name, .type = FormatZigType{ .type = &param.type } });
            if (func.variadic or i < func.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
        if (func.variadic) try io_writer.print("...", .{});

        try io_writer.print(") {[return_type]f};\n", .{
            .return_type = FormatZigType{ .type = &func.return_type },
        });
    }
}

const FormatZigStruct = struct {
    @"struct": *const Reader.CppStructDecl,
    writer: *Writer,

    pub fn format(fmt: FormatZigStruct, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.@"struct".fields.items) |field| {
            if (field.bitfield) {
                try io_writer.print("pub const {[name]s} = [{[size]}]u8;\n", .{ .name = fmt.@"struct".name, .size = fmt.@"struct".size });
                return;
            }
        }

        var unnamed: usize = 0;
        try io_writer.print("pub const {[name]s} = extern struct {{\n", .{ .name = fmt.@"struct".name });
        for (fmt.@"struct".fields.items) |field| {
            try io_writer.print("{s}", .{INDENT});
            if (field.name.len == 0) {
                try io_writer.print("unnamed_{}", .{unnamed});
                unnamed += 1;
            } else {
                try io_writer.print("{s}", .{field.name});
            }

            try io_writer.print(": {[type]f} align({[align_]}),\n", .{
                .type = FormatZigType{ .type = &field.type },
                .align_ = field.type.align_,
            });
        }
        try io_writer.print("}};\n", .{});
    }
};

const FormatZigEnum = struct {
    @"enum": *const Reader.CppEnumDecl,
    writer: *Writer,

    pub fn format(fmt: FormatZigEnum, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        try io_writer.print("pub const {[name]s} = packed struct({[int]f}) {{\n", .{
            .name = fmt.@"enum".name,
            .int = FormatZigType{ .type = &fmt.@"enum".int },
        });
        try io_writer.print("{[indent]s}value: {[int]f},", .{
            .indent = INDENT,
            .int = FormatZigType{ .type = &fmt.@"enum".int },
        });

        for (fmt.@"enum".decls.items) |decl| {
            try io_writer.print("{[indent]s}pub const {[name]s}: {[int]f} = {[value]};\n", .{
                .indent = INDENT,
                .int = FormatZigType{ .type = &fmt.@"enum".int },
                .name = decl.@"0",
                .value = decl.@"1",
            });
        }

        try io_writer.print("}};\n", .{});
    }
};

pub const FormatZigType = struct {
    type: *const Reader.CppType,

    pub fn format(fmt: FormatZigType, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        // if (fmt.writer.annotate) {
        //     try io_writer.print("/* {}:{s}:{}:'{s}' */ ", .{
        //         fmt.writer.debug_idx,
        //         @tagName(fmt.type.inner),
        //         fmt.type.is_const,
        //         fmt.type.raw_type_spelling,
        //     });
        // }
        // fmt.writer.debug_idx += 1;

        switch (fmt.type.inner) {
            .pointer, .reference, .closure => {
                try io_writer.print("?*", .{});
                if (fmt.type.is_const and fmt.type.inner != .reference) {
                    try io_writer.print("const ", .{});
                }
            },
            else => {},
        }

        switch (fmt.type.inner) {
            // TODO: This might be a good use-case for retaining the CXType.
            .unexposed => try io_writer.print("[{}]u8", .{fmt.type.size}),
            .void => try io_writer.print("void", .{}),
            .bool => try io_writer.print("bool", .{}),
            .i8 => try io_writer.print("i8", .{}),
            .u8 => try io_writer.print("u8", .{}),
            .i16 => try io_writer.print("i16", .{}),
            .u16 => try io_writer.print("u16", .{}),
            .i32 => try io_writer.print("i32", .{}),
            .u32 => try io_writer.print("u32", .{}),
            .i64 => try io_writer.print("i64", .{}),
            .u64 => try io_writer.print("u64", .{}),
            .f32 => try io_writer.print("f32", .{}),
            .f64 => try io_writer.print("f64", .{}),
            .pointer => |pointee| try (FormatZigType{ .type = pointee }).format(io_writer),
            .reference => |ref| try (FormatZigType{ .type = ref }).format(io_writer),
            .array => |arr| {
                try io_writer.print("[{[count]}]{[elm]f}", .{
                    .count = arr.@"0",
                    .elm = FormatZigType{ .type = arr.@"1" },
                });
            },
            .slice => |elm| {
                try io_writer.print("[]{[elm]f}", .{
                    .elm = FormatZigType{ .type = elm },
                });
            },
            .record => |st| try io_writer.print("{s}", .{st.@"1"}),
            .@"enum" => |name| try io_writer.print("{s}", .{name}),
            .closure => |_| try io_writer.print("anyopaque", .{}),
            .anon => try io_writer.print("[{[size]}]u8", .{.size = fmt.type.size}),
        }
    }
};

// -- Helpers -- //

fn fatal(e: anyerror) noreturn {
    std.log.err("Error: {}", .{e});
    @panic("Write error! See above.");
}
