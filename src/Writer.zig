//! Given the results of `read.zig`'s parsing, outputs an `extern "C"` compatible .cpp file for FFI
//! usage as well as a Zig binding.

// -- Imports -- //

const std = @import("std");

const Reader = @import("Reader.zig");
const Writer = @This();

const AST = Reader.AST;
const CppType = Reader.CppType;

const Allocator = std.mem.Allocator;

// -- Constants -- //

const INDENT = "    ";

const log = std.log.scoped(.writer);

// -- State -- //

target: Target,
annotate: bool = false,

allocator: Allocator,
source_filename: []const u8,
ast: AST,

debug_idx: usize = 0,
written_functions: std.StringHashMap(usize),

const Target = enum {
    Cpp,
    Zig,
};

// -- Formatting -- //

pub fn format(writer: *Writer, io_writer: *std.io.Writer) !void {
    switch (writer.target) {
        .Cpp => try formatCpp(writer, io_writer),
        .Zig => try formatZig(writer, io_writer),
    }
}

// -- C++ -- //

const CPP_TEMPLATE_FILE =
    \\// This file was auto-generated by github:nukkeldev/zpp.
    \\// It is an extern "C" compatible wrapper for the include below.
    \\
    \\#include "{[filename]s}"
    \\
    \\#include <cstdarg>
    \\
    \\#pragma clang diagnostic push
    \\#pragma clang diagnostic ignored "-Wformat-security"
    \\
    \\extern "C" {{ // extern "C"
    \\{[functions]f}
    \\}} // extern "C"
    \\
    \\#pragma clang diagnostic pop
    \\
;

const CPP_TEMPLATE_FUNCTION =
    \\{[indent]s}{[return_type]f} {[name_namespace_prefix]s}{[name]s}{[overload_idx]s}({[parameters]f}) {{
    \\{[indent]s}{[indent]s}{[might_return]s}{[return_prefix]s}{[namespace_prefix]s}{[name]s}({[arguments]f}){[return_suffix]s};
    \\{[indent]s}}}
    \\
;

const CPP_TEMPLATE_VARIADIC_FUNCTION =
    \\{[indent]s}{[return_type]f} {[name_namespace_prefix]s}{[name]s}{[overload_idx]s}({[parameters]f}) {{
    \\{[indent]s}{[indent]s}va_list ZPP_args;
    \\{[indent]s}{[indent]s}va_start(ZPP_args, {[after_param]s});
    \\{[indent]s}{[indent]s}{[might_return]s}{[return_prefix]s}{[namespace_prefix]s}{[name]s}({[arguments]f}){[return_suffix]s};
    \\{[indent]s}{[indent]s}va_end(ZPP_args);
    \\{[indent]s}}}
    \\
;

pub fn formatCpp(writer: *Writer, io_writer: *std.io.Writer) !void {
    log.debug("Writing AST as C++ file.", .{});
    try io_writer.print(CPP_TEMPLATE_FILE, .{
        .filename = writer.source_filename,
        .functions = FormatCppFunctions{ .writer = writer },
    });
}

const FormatCppFunctions = struct {
    writer: *Writer,

    pub fn format(fmt: FormatCppFunctions, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        log.debug("Writing {} functions.", .{fmt.writer.ast.functions.items.len});
        for (fmt.writer.ast.functions.items) |*func| {
            log.debug("Writing function '{s}' in resolved namespace '{s}'.", .{ func.name, func.resolved_namespace_prefix });
            const overload_idx_ptr = (fmt.writer.written_functions.getOrPutValue(func.name, 0) catch |e| fatal(e)).value_ptr;
            if (overload_idx_ptr.* > 0) log.debug("This is overload #{}.", .{overload_idx_ptr.*});

            const overload_idx = if (overload_idx_ptr.* > 0)
                std.fmt.allocPrint(fmt.writer.allocator, "{}", .{overload_idx_ptr.*}) catch |e| fatal(e)
            else
                "";

            const how_should_i_handle_the_return_type = howShouldIHandleTheReturnType(&func.return_type);
            log.debug("Return type of '{s}' means we will use {}.", .{ @tagName(func.return_type.inner), how_should_i_handle_the_return_type });

            const return_type = if (how_should_i_handle_the_return_type == .Primitive)
                FormatCppType{ .type = &func.return_type, .writer = fmt.writer }
            else
                FormatCppType{ .type = &CppType{ .is_const = false, .inner = .void }, .writer = fmt.writer };

            const namespace_prefix = Reader.getNamespacePrefixWithSeperator(fmt.writer.allocator, func.namespace, &fmt.writer.ast, "::") catch |e| fatal(e);

            const might_return = if (how_should_i_handle_the_return_type == .Primitive) "return " else "";
            const return_prefix = if (func.return_type.inner == .reference) "&" else "";

            if (func.variadic) {
                try io_writer.print(CPP_TEMPLATE_VARIADIC_FUNCTION, .{
                    .indent = INDENT,
                    .return_type = return_type,
                    .after_param = func.parameters.getLast().name,
                    .name_namespace_prefix = func.resolved_namespace_prefix,
                    .name = func.name,
                    .overload_idx = overload_idx,
                    .parameters = FormatCppParameters{ .func = func, .writer = fmt.writer },
                    .might_return = might_return,
                    .return_prefix = return_prefix, // TODO
                    .namespace_prefix = namespace_prefix,
                    .arguments = FormatCppArguments{ .func = func, .writer = fmt.writer },
                    .return_suffix = "", // TODO
                });
            } else {
                try io_writer.print(CPP_TEMPLATE_FUNCTION, .{
                    .indent = INDENT,
                    .return_type = return_type,
                    .name_namespace_prefix = func.resolved_namespace_prefix,
                    .name = func.name,
                    .overload_idx = overload_idx,
                    .parameters = FormatCppParameters{ .func = func, .writer = fmt.writer },
                    .might_return = might_return,
                    .return_prefix = return_prefix, // TODO
                    .namespace_prefix = namespace_prefix,
                    .arguments = FormatCppArguments{ .func = func, .writer = fmt.writer },
                    .return_suffix = "", // TODO
                });
            }
            overload_idx_ptr.* += 1;
        }
    }
};

const FormatCppParameters = struct {
    func: *const Reader.CppFunctionDecl,
    writer: *Writer,

    pub fn format(fmt: FormatCppParameters, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.func.parameters.items, 0..) |param, i| {
            switch (param.type.inner) {
                .array => |arr| try io_writer.print("{f} {s}[{}]", .{ FormatCppType{ .type = arr.@"1", .writer = fmt.writer }, param.name, arr.@"0" }),
                .slice => |elm| try io_writer.print("{f} {s}[]", .{ FormatCppType{ .type = elm, .writer = fmt.writer }, param.name }),
                .pointer => |pointee| switch (pointee.inner) {
                    .closure => |idx| {
                        const decl = fmt.writer.ast.closures.items[idx];
                        try io_writer.print("{[return_type]f} (*{[name]s})({[parameters]f})", .{
                            .return_type = FormatCppType{ .type = &decl.return_type, .writer = fmt.writer },
                            .name = param.name,
                            .parameters = FormatCppClosureParameters{ .decl = &decl, .writer = fmt.writer },
                        });
                    },
                    else => try io_writer.print("{f} {s}", .{ FormatCppType{ .type = &param.type, .writer = fmt.writer }, param.name }),
                },
                else => try io_writer.print("{f} {s}", .{ FormatCppType{ .type = &param.type, .writer = fmt.writer }, param.name }),
            }
            if (fmt.func.variadic or i < fmt.func.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
        if (fmt.func.variadic) try io_writer.print("...", .{});
    }
};

const FormatCppArguments = struct {
    func: *const Reader.CppFunctionDecl,
    writer: *Writer,

    pub fn format(fmt: FormatCppArguments, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.func.parameters.items, 0..) |param, i| {
            switch (param.type.inner) {
                .reference => try io_writer.print("*{s}", .{param.name}),
                .pointer => try io_writer.print("reinterpret_cast<{s}>({s})", .{ param.type.raw_type_spelling, param.name }),
                else => try io_writer.print("{s}", .{param.name}),
            }
            if (i < fmt.func.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
    }
};

const FormatCppClosureParameters = struct {
    decl: *const Reader.CppFunctionDecl,
    writer: *Writer,

    pub fn format(fmt: FormatCppClosureParameters, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        for (fmt.decl.parameters.items, 0..) |param, i| {
            try (FormatCppType{ .type = &param.type, .writer = fmt.writer }).format(io_writer);
            if (i < fmt.decl.parameters.items.len - 1) try io_writer.print(", ", .{});
        }
    }
};

const FormatCppType = struct {
    type: *const CppType,
    writer: *Writer,
    ignore_const: bool = false,

    pub fn format(fmt: FormatCppType, io_writer: *std.io.Writer) std.io.Writer.Error!void {
        log.debug("[{}] Formatting type '{s}'.", .{ fmt.writer.debug_idx, @tagName(fmt.type.inner) });
        if (fmt.type.is_const) {
            log.debug("Type is const.", .{});
            if (fmt.ignore_const) log.debug("But we are ignoring that...", .{});
        }

        if (fmt.writer.annotate) {
            try io_writer.print("/* {}:{s}:{}:'{s}' */ ", .{
                fmt.writer.debug_idx,
                @tagName(fmt.type.inner),
                fmt.type.is_const,
                fmt.type.raw_type_spelling,
            });
        }
        fmt.writer.debug_idx += 1;
        if (!fmt.ignore_const and fmt.type.is_const) try io_writer.print("const ", .{});

        switch (fmt.type.inner) {
            // TODO: This might be a good use-case for retaining the CXType.
            .unexposed => try io_writer.print("void*", .{}),
            .void => try io_writer.print("void", .{}),
            .bool => try io_writer.print("bool", .{}),
            .i8 => try io_writer.print("char", .{}),
            .u8 => try io_writer.print("unsigned char", .{}),
            .i16 => try io_writer.print("short", .{}),
            .u16 => try io_writer.print("unsigned short", .{}),
            .i32 => try io_writer.print("int", .{}),
            .u32 => try io_writer.print("unsigned int", .{}),
            .i64 => try io_writer.print("long long", .{}),
            .u64 => try io_writer.print("unsigned long long", .{}),
            .f32 => try io_writer.print("float", .{}),
            .f64 => try io_writer.print("double", .{}),
            .pointer => |pointee| try io_writer.print("{f}*", .{FormatCppType{ .type = pointee, .writer = fmt.writer, .ignore_const = fmt.type.is_const or fmt.ignore_const }}),
            .reference => |ref| try io_writer.print("{f}*", .{FormatCppType{ .type = ref, .writer = fmt.writer, .ignore_const = fmt.type.is_const or fmt.ignore_const }}),
            .array, .slice => @panic("TODO: I don't think you can do this as a return type?"),
            .record => |name| try io_writer.print("{s}", .{name}),
            .@"enum" => |name| try io_writer.print("{s}", .{name}),
            .closure => |_| try io_writer.print("void*", .{}),
        }
    }
};

const ReturnTypeBehav = enum {
    Void,
    Primitive,
    Record,
};

fn howShouldIHandleTheReturnType(cpp_type: *const CppType) ReturnTypeBehav {
    return switch (cpp_type.inner) {
        .void, .pointer => .Void,
        .record => .Record,
        else => .Primitive,
    };
}

// -- Zig -- //

pub fn formatZig(writer: *Writer, io_writer: *std.io.Writer) !void {
    _ = writer;
    _ = io_writer;
}

// -- Helpers -- //

fn fatal(e: anyerror) noreturn {
    std.log.err("Error: {}", .{e});
    @panic("Write error! See above.");
}
