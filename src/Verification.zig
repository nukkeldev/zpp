// -- Imports -- //

const std = @import("std");

const Reader = @import("Reader.zig");
const Writer = @import("Writer.zig");
const Verification = @This();

const AST = Reader.AST;
const CppType = Reader.CppType;

const Allocator = std.mem.Allocator;

// -- Constants -- //

const INDENT = "    ";

const log = std.log.scoped(.verif);

// -- State -- //

/// The language we are writing.
language: Language,

/// An allocator; nothing is freed.
allocator: Allocator,
/// The source filename that the AST came from.
/// Used, for instance, for including symbols in C++.
source_filename: []const u8,
/// The abstract syntax tree.
ast: AST,

/// The language target for the `Verification`.
const Language = enum {
    /// Writes the C++ functions for the verification functions.
    Cpp,
    /// Writes the Zig bindings for the verification functions, requires the Writer's zig bindings.
    Zig,
};

// -- Formatting -- //

pub fn format(fmt: Verification, io_writer: *std.io.Writer) std.io.Writer.Error!void {
    try io_writer.print(
        \\// This file was auto-generated by github:nukkeldev/zpp.
        \\// It provides functions to verify ABI-compatibility.
        \\
        \\
    , .{});

    switch (fmt.language) {
        .Cpp => {
            try io_writer.print("#include \"{s}\"\n#include <stdio.h>\n#include <cstdint>\n\n", .{fmt.source_filename});

            {
                try io_writer.print("struct ABISizes {{\n", .{});
                var struct_iter = fmt.ast.structs.valueIterator();
                while (struct_iter.next()) |st| {
                    if (st.fields.items.len == 0) continue;
                    try io_writer.print("{[indent]s}{[indent]s}uint32_t sizeof_{[name]s};\n", .{ .indent = INDENT, .name = st.name });
                }
                try io_writer.print("}};\n\n", .{});
            }

            {
                try io_writer.print(
                    "extern \"C\" bool __verifyABI(ABISizes sizes) {{\n{[indent]s}bool error = false;\n\n",
                    .{ .indent = INDENT },
                );
                var struct_iter = fmt.ast.structs.valueIterator();
                while (struct_iter.next()) |st| {
                    if (st.fields.items.len == 0) continue;
                    try io_writer.print(
                        \\{[indent]s}if (sizes.sizeof_{[name]s} != sizeof({[name]s})) {{
                        \\{[indent]s}{[indent]s}printf("ERROR: struct {[name]s} should be %d bytes, but was %d bytes!\n", sizeof({[name]s}), sizes.sizeof_{[name]s});
                        \\{[indent]s}{[indent]s}error = true;
                        \\{[indent]s}}}
                        \\
                    , .{ .indent = INDENT, .name = st.name });
                }
                try io_writer.print("\n{[indent]s}return !error;\n{[indent]s}}}\n\n", .{ .indent = INDENT });
            }

            var struct_iter = fmt.ast.structs.valueIterator();
            while (struct_iter.next()) |st| outer: {
                if (st.fields.items.len == 0) continue;
                for (st.fields.items) |field| {
                    if (field.type.inner == .anon or field.bitfield) {
                        break :outer;
                    }
                }

                {
                    try io_writer.print("struct {s}Fields {{\n", .{st.name});
                    for (st.fields.items) |field| {
                        try io_writer.print("{[indent]s}uint32_t offsetof_{[name]s};\n", .{ .indent = INDENT, .name = field.name });
                        try io_writer.print("{[indent]s}uint32_t sizeof_{[name]s};\n", .{ .indent = INDENT, .name = field.name });
                    }
                    try io_writer.print("}};\n\n", .{});
                }

                try io_writer.print(
                    \\extern "C" bool __verify{[name]s}({[name]s}Fields fields) {{
                    \\
                , .{ .name = st.name });

                for (st.fields.items) |field| {
                    try io_writer.print(
                        \\{[indent]s}if (fields.offsetof_{[name]s} != offsetof({[st]s}, {[name]s})) {{
                        \\{[indent]s}{[indent]s}printf("ERROR: struct {[st]s} field {[name]s} should be offset %d bytes, but was offset %d bytes!\n", offsetof({[st]s}, {[name]s}), fields.offsetof_{[name]s});
                        \\{[indent]s}{[indent]s}return false;
                        \\{[indent]s}}}
                        \\
                        \\{[indent]s}if (fields.sizeof_{[name]s} != sizeof((({[st]s}*)nullptr)->{[name]s})) {{
                        \\{[indent]s}{[indent]s}printf("ERROR: struct {[st]s} field {[name]s} should be sized %d bytes, but was sized %d bytes!\n", sizeof((({[st]s}*)nullptr)->{[name]s}), fields.sizeof_{[name]s});
                        \\{[indent]s}{[indent]s}return false;
                        \\{[indent]s}}}
                        \\
                    , .{ .indent = INDENT, .name = field.name, .st = st.name });
                }

                try io_writer.print("\n{[indent]s}return true;\n}}\n\n", .{ .indent = INDENT });
            }
        },
        .Zig => {
            try io_writer.print("const Bindings = @import(\"{s}.zig\");\n\n", .{fmt.source_filename});

            try io_writer.print("pub fn verifyABI() bool {{ return __verifyABI(.{{}}); }}\n", .{});
            try io_writer.print("pub extern fn __verifyABI(sizes: extern struct {{\n", .{});
            var struct_iter = fmt.ast.structs.valueIterator();
            while (struct_iter.next()) |st| {
                if (st.fields.items.len == 0) continue;
                try io_writer.print("{[indent]s}{[name]s}: u32 = @sizeOf(Bindings.{[name]s}),\n", .{ .indent = INDENT, .name = st.name });
            }
            try io_writer.print("}}) bool;\n\n", .{});

            struct_iter = fmt.ast.structs.valueIterator();
            while (struct_iter.next()) |st| {
                if (st.fields.items.len == 0) continue;

                outer: {
                    for (st.fields.items) |field| if (field.type.inner == .anon) {
                        try io_writer.print("// TODO: Struct '{s}' with anonymous union field not yet implemented!\n\n", .{st.name});
                        break :outer;
                    };
                    try io_writer.print("pub fn verify{[name]s}() bool {{ return __verify{[name]s}(.{{}}); }}\n", .{
                        .name = st.name,
                    });
                    try io_writer.print("pub extern fn __verify{s}(fields: extern struct {{\n", .{st.name});
                    for (st.fields.items) |field| {
                        try io_writer.print("{[indent]s}offsetof_{[field]s}: u32 = @offsetOf(Bindings.{[name]s}, \"{[field]s}\"),\n", .{
                            .indent = INDENT,
                            .name = st.name,
                            .field = field.name,
                        });
                        try io_writer.print("{[indent]s}sizeof_{[field]s}: u32 = @sizeOf(@FieldType(Bindings.{[name]s}, \"{[field]s}\")),\n", .{
                            .indent = INDENT,
                            .name = st.name,
                            .field = field.name,
                        });
                    }
                    try io_writer.print("}}) bool;\n\n", .{});
                }
            }

            try io_writer.print("pub fn verifyAll() bool {{\n{[indent]s}var err = false;\n", .{ .indent = INDENT });
            struct_iter = fmt.ast.structs.valueIterator();
            while (struct_iter.next()) |st| {
                outer: {
                    if (st.fields.items.len == 0) continue;
                    for (st.fields.items) |field| {
                        if (field.type.inner == .anon or field.bitfield) {
                            break :outer;
                        }
                    }
                    try io_writer.print("{[indent]s}err |= verify{[name]s}();\n", .{ .indent = INDENT, .name = st.name });
                }
            }
            try io_writer.print("{[indent]s}return !err;\n}}\n\n", .{ .indent = INDENT });
        },
    }
}
