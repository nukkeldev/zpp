// This file was auto-generated by github:nukkeldev/zpp; I wouldn't recommend editing it.

fn refAllDecls(comptime T: type) void {
    inline for (comptime @import("std").meta.declarations(T)) |decl| {
        _ = &@field(T, decl.name);
    }
}

pub const AlsoStruct = Struct;

pub const AlsoOpaque = Opaque;

pub const AlsoInlineOpaque = InlineOpaque;

pub const InlinePOD = extern struct {
    x: i32,
    comptime {
        if (@sizeOf(@This()) != 4 or @alignOf(@This()) != 4) {
            @compileLog(@import("std").fmt.comptimePrint("Expected type 'InlinePOD' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                @sizeOf(@This()),
                @alignOf(@This()),
            }));

            const this: @This() = undefined;

            const T_x = @TypeOf(this.x);
            if (@sizeOf(T_x) != 4 or @alignOf(T_x) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'x' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_x),
                    @alignOf(T_x),
                }));
            }
        }
    }
};

pub const POD = extern struct {
    x: i32,
    y: i32,
    comptime {
        if (@sizeOf(@This()) != 8 or @alignOf(@This()) != 4) {
            @compileLog(@import("std").fmt.comptimePrint("Expected type 'POD' to be 8 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                @sizeOf(@This()),
                @alignOf(@This()),
            }));

            const this: @This() = undefined;

            const T_x = @TypeOf(this.x);
            if (@sizeOf(T_x) != 4 or @alignOf(T_x) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'x' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_x),
                    @alignOf(T_x),
                }));
            }
            const T_y = @TypeOf(this.y);
            if (@sizeOf(T_y) != 4 or @alignOf(T_y) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'y' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_y),
                    @alignOf(T_y),
                }));
            }
        }
    }
};

pub const Struct = extern struct {
    x: i32,
    y: i32,
    comptime {
        if (@sizeOf(@This()) != 8 or @alignOf(@This()) != 4) {
            @compileLog(@import("std").fmt.comptimePrint("Expected type 'Struct' to be 8 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                @sizeOf(@This()),
                @alignOf(@This()),
            }));

            const this: @This() = undefined;

            const T_x = @TypeOf(this.x);
            if (@sizeOf(T_x) != 4 or @alignOf(T_x) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'x' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_x),
                    @alignOf(T_x),
                }));
            }
            const T_y = @TypeOf(this.y);
            if (@sizeOf(T_y) != 4 or @alignOf(T_y) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'y' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_y),
                    @alignOf(T_y),
                }));
            }
        }
    }
};

pub const StructWithAnonymousUnion = extern struct {
    x: i32,
    anon0: extern union {
        y: f32,
        z: f64,
        w: u8,
        comptime {
            if (@sizeOf(@This()) != 8 or @alignOf(@This()) != 8) {
                @compileLog(@import("std").fmt.comptimePrint("Expected type 'Anonymous Type' to be 8 bytes with 8 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(@This()),
                    @alignOf(@This()),
                }));

                const this: @This() = undefined;

                const T_y = @TypeOf(this.y);
                if (@sizeOf(T_y) != 4 or @alignOf(T_y) != 4) {
                    @compileLog(@import("std").fmt.comptimePrint("Expected field 'y' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                        @sizeOf(T_y),
                        @alignOf(T_y),
                    }));
                }
                const T_z = @TypeOf(this.z);
                if (@sizeOf(T_z) != 8 or @alignOf(T_z) != 8) {
                    @compileLog(@import("std").fmt.comptimePrint("Expected field 'z' to be 8 bytes with 8 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                        @sizeOf(T_z),
                        @alignOf(T_z),
                    }));
                }
                const T_w = @TypeOf(this.w);
                if (@sizeOf(T_w) != 1 or @alignOf(T_w) != 1) {
                    @compileLog(@import("std").fmt.comptimePrint("Expected field 'w' to be 1 bytes with 1 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                        @sizeOf(T_w),
                        @alignOf(T_w),
                    }));
                }
            }
        }
    },
    comptime {
        if (@sizeOf(@This()) != 16 or @alignOf(@This()) != 8) {
            @compileLog(@import("std").fmt.comptimePrint("Expected type 'StructWithAnonymousUnion' to be 16 bytes with 8 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                @sizeOf(@This()),
                @alignOf(@This()),
            }));

            const this: @This() = undefined;

            const T_x = @TypeOf(this.x);
            if (@sizeOf(T_x) != 4 or @alignOf(T_x) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'x' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_x),
                    @alignOf(T_x),
                }));
            }
        }
    }
};

pub const Enum = packed struct(u32) {
    data: u32,
    pub const A: Enum = .{ .data = 0 };
    pub const B: Enum = .{ .data = 2 };
    pub const C: Enum = .{ .data = 1 };
};

pub const Union = extern union {
    x: i32,
    y: f32,
    z: [*c]u8,
    comptime {
        if (@sizeOf(@This()) != 8 or @alignOf(@This()) != 8) {
            @compileLog(@import("std").fmt.comptimePrint("Expected type 'Union' to be 8 bytes with 8 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                @sizeOf(@This()),
                @alignOf(@This()),
            }));

            const this: @This() = undefined;

            const T_x = @TypeOf(this.x);
            if (@sizeOf(T_x) != 4 or @alignOf(T_x) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'x' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_x),
                    @alignOf(T_x),
                }));
            }
            const T_y = @TypeOf(this.y);
            if (@sizeOf(T_y) != 4 or @alignOf(T_y) != 4) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'y' to be 4 bytes with 4 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_y),
                    @alignOf(T_y),
                }));
            }
            const T_z = @TypeOf(this.z);
            if (@sizeOf(T_z) != 8 or @alignOf(T_z) != 8) {
                @compileLog(@import("std").fmt.comptimePrint("Expected field 'z' to be 8 bytes with 8 byte alignment, but was {} bytes with {} byte alignment instead!", .{
                    @sizeOf(T_z),
                    @alignOf(T_z),
                }));
            }
        }
    }
};

pub const ret_void = ret_void__efeffba39ae7af53;
extern fn ret_void__efeffba39ae7af53() callconv(.c) void;

pub const one_prim_ret_void = one_prim_ret_void__4a917f4659445867;
extern fn one_prim_ret_void__4a917f4659445867(param1: i32) callconv(.c) void;

pub const n_prim_ret_void = n_prim_ret_void__98e758a5c3431362;
extern fn n_prim_ret_void__98e758a5c3431362(param1: i32, param2: i32, param3: i32) callconv(.c) void;

pub const one_prim_vararg_ret_void = one_prim_vararg_ret_void__5cabac90c72e4be6;
extern fn one_prim_vararg_ret_void__5cabac90c72e4be6(n: i32, ...) callconv(.c) void;

pub const one_ptr_ret_void = one_ptr_ret_void__1f485662f262acb6;
extern fn one_ptr_ret_void__1f485662f262acb6(x: [*c]i32) callconv(.c) void;

pub const one_const_ptr_ret_void = one_const_ptr_ret_void__f558d7d0e16f5f16;
extern fn one_const_ptr_ret_void__f558d7d0e16f5f16(x: [*c]const i32) callconv(.c) void;

pub const one_ref_ret_void = one_ref_ret_void__b70024789e28fa38;
extern fn one_ref_ret_void__b70024789e28fa38(x: *i32) callconv(.c) void;

pub const one_arr_ret_void = one_arr_ret_void__ee664445c8e6b67c;
extern fn one_arr_ret_void__ee664445c8e6b67c(color: [*]i32) callconv(.c) void;

pub const one_slice_ret_void = one_slice_ret_void__61d802eb13710e12;
extern fn one_slice_ret_void__61d802eb13710e12(color: [*]i32) callconv(.c) void;

pub const one_prim_def_val_ret_void = one_prim_def_val_ret_void__62660cf3e033c789;
extern fn one_prim_def_val_ret_void__62660cf3e033c789(x: i32) callconv(.c) void;

pub const ret_prim = ret_prim__7b22e02c3234c677;
extern fn ret_prim__7b22e02c3234c677() callconv(.c) i32;

pub const ret_pod = ret_pod__93c835f1e7091cf5;
extern fn ret_pod__93c835f1e7091cf5(zpp_out: *POD) callconv(.c) void;

pub const ret_struct = ret_struct__26cf40dc9ca765c1;
extern fn ret_struct__26cf40dc9ca765c1(zpp_out: *Struct) callconv(.c) void;

pub const ret_enum = ret_enum__f2347161b8b19cf2;
extern fn ret_enum__f2347161b8b19cf2() callconv(.c) Enum;

pub const ret_union = ret_union__6b6da98868f815ae;
extern fn ret_union__6b6da98868f815ae(zpp_out: *Union) callconv(.c) void;

pub const ret_ptr = ret_ptr__3d4bde5d4001f950;
extern fn ret_ptr__3d4bde5d4001f950() callconv(.c) [*c]i32;

pub const ret_const_ptr = ret_const_ptr__d2471e1a9d1d29b2;
extern fn ret_const_ptr__d2471e1a9d1d29b2() callconv(.c) [*c]const i32;

pub const one_prim_vararg_ret_struct = one_prim_vararg_ret_struct__631eb1965d0ed24d;
extern fn one_prim_vararg_ret_struct__631eb1965d0ed24d(s: i32, zpp_out: *Struct, ...) callconv(.c) void;

pub const NS1 = struct {
    pub const foo = NS1_foo__1b03ba031047298e;
    extern fn NS1_foo__1b03ba031047298e() callconv(.c) i32;

    pub const bar = NS1_bar__99b394cdf1430e0c;
    extern fn NS1_bar__99b394cdf1430e0c(baz: i32) callconv(.c) void;

    pub const foo2 = NS1_foo2__46d295638d55860f;
    extern fn NS1_foo2__46d295638d55860f() callconv(.c) i32;

    comptime {
        refAllDecls(@This());
    }
};

pub const after_ns = after_ns__7ff6830c2603e947;
extern fn after_ns__7ff6830c2603e947() callconv(.c) void;

pub const lotsOfTypes = lotsOfTypes__85c39383158c72ab;
extern fn lotsOfTypes__85c39383158c72ab(c: u8, sc: i8, uc: u8, s: i16, us: u16, i: i32, ui: u32, l: i64, ul: u64, ll: i64, ull: u64, f: f32, d: f64, ld: f128, slice: [*]i32, array: [*]i32, func: [*c]*const fn (u8, bool, u16) callconv(.c) i32, func_ptr: [*c][*c]*const fn (u8, bool, u16) callconv(.c) i32) callconv(.c) void;

pub const Opaque = ?*anyopaque;
pub const ZST2 = extern struct {};
pub const InlineOpaque = ?*anyopaque;
pub const ZST = extern struct {};

comptime {
    refAllDecls(@This());
}
